<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <head>
    <title>DudleyD3 - Sosolimited</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
  </head>
  <body>
    <div class="wrapper">

      <div id="game_title"><h1>Dudley D3 Dashboard</h1></div>

      <div id="graph_container_1" class="graph_container full_row">
        <h2>Overall Requests/Day</h2>
        <div id="graph_1"></div>
      </div>
      
    </div>
    
  <script src="js/jquery-1.11.1.min.js"></script>
  <script src="js/d3.min.js"></script>
  <script src="js/common.js"></script>
  <script type="text/javascript" charset="utf-8">
    
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - General - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // Set default teams and colors. Is overwritten by results of our JSON calls.
    var cur_teams = { "afc" : "none", "nfc" : "none" };
    var cur_colors = { "afc" : "black", "nfc" : "black" };

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Vars : Time series charts - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // to store the current chart's data
    var data;

    // Vars for all charts size.
    margin = {top: 30, right: 30, bottom: 30, left: 40};
    width = 950 - margin.left - margin.right;
    height = 400 - margin.top - margin.bottom;
    // Our Date parsing formats.
    // TODO: right now the way we handle different data streams is by ignorning whole unit measures (ie. 15 minutes, single minutes) instead of treating individual null values. Need to add handling for that.
    // We have different parsing formats depending on the type of data: daily, hourly, by minute, etc.
    var parseDateFormat1 = d3.time.format("%Y,%m,%d,%H").parse;             // For data per hour. "%-" means it ignores padding, removing the need for zero-padding perhaps?
    var parseDateFormat2 = d3.time.format("%Y,%m,%d,%H,%M").parse;          // For data per minute.

    
    var charts = [];    
    // For each chart, this array contains : [0] = the data url, [1] = the desired front dataset (the AFC team or NFC team), [2] = the desired back dataset (AFC or NFC), [3] = the parse format, (optional)[4] = the smoothing amount.
    // Some data urls are the live API, some are backed-up data files.
    var charts_data = [ 
                        // ["http://wgwapi.com/game/confidence?time=min&start=" + formattedStartDate + "&end=" +formattedEndDate, "nfc", "afc", 2, 20, true]
                        // ["https://mayors24.cityofboston.gov/open311/v2/requests.json?page=1&page_size=10"]
                        // ["http://sosolimited.com/superbowl/WGW-D3-Charts/data/data-nov7chiefsbroncos-tweets-timemin-num1440.json"]
                        ["data/dudley-page=1&page_size=1000.json", "Request locations"]
                      ];
    
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Init : Time series charts - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // this call starts everything.
    setup_charts();

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Functions - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // setup chart objects and data.
    function setup_charts() {
      
      for (var i = 0; i < charts_data.length; i++) {

        // Set the current chart var.
        var cur_chart = d3.select("#graph_" + (i+1) ).append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .attr("top", 100)
          .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");  
        charts[i] = cur_chart;

        // Set the chart's title.
        d3.select("#graph_container_"+ (i+1) +" h2").html(charts_data[i][1]);

        // Call the JSON data. For the data we currently have, value1 = Broncos (orange), and value2 = Chiefs (red).
        // Using a function/closure to localize "i" (and giving it another name, "this_i") so that "i" doesn't always end-up being the last index of the loop.
        (function(this_i){      //"localizing" i by using it in the inner function
          
          d3.json(charts_data[this_i][0], function(error, json_data) {
            
            console.log("- - - - - - - - - - - - - - - - - - #"+ this_i +" DATA : ")
            console.log(json_data);

            
            // - - - - MAKE CHART: Location Long/Lat scatterplot
            
            var x = d3.scale.linear()
              .range([0, width]);

            var y = d3.scale.linear()
              .range([height, 0]);

            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");

            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

            json_data.forEach(function(d) {
              d.lat = +d.lat;
              d.long = +d.long;
            });

            x.domain(d3.extent(json_data, function(d) { return d.lat; })).nice();
            y.domain(d3.extent(json_data, function(d) { return d.long; })).nice();

            charts[this_i].append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis)
              .append("text")
                .attr("class", "label")
                .attr("x", width)
                .attr("y", -6)
                .style("text-anchor", "end")
                .text("Latitude");

            charts[this_i].append("g")
                .attr("class", "y axis")
                .call(yAxis)
              .append("text")
                .attr("class", "label")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .text("Longitude");

            charts[this_i].selectAll(".dot")
              .data(json_data)
            .enter().append("circle")
              .attr("class", "dot")
              .attr("r", 3.5)
              .attr("cx", function(d) { return x(d.lat); })
              .attr("cy", function(d) { return y(d.long); });


            // NOT WORKING - - - - MAKE CHART: Requests/day
            /*
            // json_data = json_data.slice();

            var parseDate = d3.time.format("%Y-%m-%d%Z").parse;

            // Build array of count of requests/day.
            var counts = {};
            json_data.forEach(function(row) {
                row.requested_datetime = row.requested_datetime.slice(0, -3) + row.requested_datetime.slice(-2);     // remove the colon ':' from the timezone at the end.
                row.requested_datetime = row.requested_datetime.slice(0, 10) + row.requested_datetime.slice(-5);     // keep only the date (year,month,day,timezone) ; remove the hour+minute+seconds.
                // console.log("day1: "+ row.requested_datetime);
                row.requested_datetime = parseDate(String(row.requested_datetime));                                  //TODO: timezone isn't working correctly....
                // console.log("day2: "+ row.requested_datetime);

                if (!counts[row.requested_datetime]) {
                    counts[row.requested_datetime] = 0;
                }
                counts[row.requested_datetime]++;
            });
            // Build objects of {day, count}.
            var data = [];
            Object.keys(counts).forEach(function(key) {
                data.push({
                    requested_datetime: key,
                    requests: counts[key]
                });
            });
            console.log("counts: ");
            console.log(counts);
            console.log("data: ");
            console.log(data);

            // Replace old data with our newly compiled data.
            json_data = data.slice();
            console.log("json_data: ");
            console.log(data);

            var x = d3.time.scale()
                .range([0, width]);
            var y = d3.scale.linear()
                .range([height, 0]);
            
            var xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");
            var yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

            var line = d3.svg.line()
              .x(function(d) { return x(d.requested_datetime); })
              .y(function(d) { return y(d.requests); });
              // .interpolate("basis");

            x.domain(d3.extent(json_data, function(d){ return d.requested_datetime; }));
            y.domain(d3.extent(json_data, function(d){ return d.requests; }));

            // Draw the X-axis of the graph.
            charts[this_i].append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);

            // Draw the Y-axis of the graph.
            charts[this_i].append("g")
                .attr("class", "y axis")
                .call(yAxis)
              .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .attr("class", "axis-text")
                .text("BLAH");
          
            charts[this_i].append("path")
                .datum(json_data)
                .attr("class", "line")
                .attr("d", line);
            */


            // - - - - MAKE CHART: service_request_ids / request_datetime
            /*
            var parseDateFormat = d3.time.format("%Y-%m-%dT%H:%M:%S").parse;          // For data per minute.
            
            x = d3.time.scale()
                .range([0, width]);
            y = d3.scale.linear()
                .range([height, 0]);
            
            xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");
            yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

            var line = d3.svg.line()
              .x(function(d) { return x(d.requested_datetime); })
              .y(function(d) { return y(d.service_request_id); });
              // .interpolate("basis");

            json_data.map(function (cur_row, index) {
              console.log("MAP -- index: "+ index);
              console.log("service_request_id = "+ cur_row.service_request_id);
              cur_row.requested_datetime = cur_row.requested_datetime.slice(0, -6);     // remove timezone at end.
              console.log("requested_datetime = "+ cur_row.requested_datetime);
              cur_row.requested_datetime = parseDateFormat(String(cur_row.requested_datetime));
              console.log("requested_datetime = "+ cur_row.requested_datetime);

              cur_row.service_request_id = +cur_row.service_request_id;
            });

            x.domain(d3.extent(json_data, function(d){ return d.requested_datetime; }));
            y.domain(d3.extent(json_data, function(d){ return d.service_request_id; }));

            // Draw the X-axis of the graph.
            charts[this_i].append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);

            // Draw the Y-axis of the graph.
            charts[this_i].append("g")
                .attr("class", "y axis")
                .call(yAxis)
              .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .attr("class", "axis-text")
                .text("BLAH");
          
            charts[this_i].append("path")
                .datum(json_data)
                .attr("class", "line")
                .attr("d", line);
            */

          });
          
        }(i));    //pass in our "i" from the loop
      }

    }
    
    // Preprocess the raw data.
    function format_raw_data(raw_data, cur_graph, front_team, back_team, parse_format, smoothing_amount, style) {
      data = {};      // clear data array
      
      // TODO: shorten code by formatting AFC and NFC in a loop of some sort.

      // AFC ----------------------------------------------------
      // rip out data from the AFC object to populate our new data array.
      raw_data.afc.map(function (cur_row, index) {
        // console.log(cur_row);
        // console.log(cur_row.time[4]);
        if (parse_format === 1) {
          cur_row.time.splice(4);                                     // TODO: removes the last 2 units for now : the 15-minute and single minute units. Eventually we need to handle them.
          cur_row.time = parseDateFormat1(String(cur_row.time));            // "time" is X value.
        } else if (parse_format === 2) {
          cur_row.time.splice(4, 1);                                  // TODO: remove the 15 minute unit but keep the single minutes, for this time format.
          cur_row.time = parseDateFormat2(String(cur_row.time));            // "time" is X value.
        }
        cur_row.value = +cur_row.value;                       // "value" is Y value. "+" converts the value to a number (not a string).
      });
      data.afc = raw_data.afc.slice();
      // console.log("1 * * * * * * * * * * AFC data = ")
      // console.log(data.afc)
      
      // apply moving-average smoothing, if specified
      if (smoothing_amount !== undefined) {
        data.afc = moving_window_average(data.afc, smoothing_amount);
      }
      // console.log("2 * * * * * * * * * * AFC data = ")
      // console.log(data.afc)

      // NFC ----------------------------------------------------
      // rip out data from the NFC object to populate our new data array.
      raw_data.nfc.map(function (cur_row, index) {
        // console.log(cur_row);
        // console.log(cur_row.time[4]);
        if (parse_format === 1) {
          cur_row.time.splice(4);                                     // TODO: removes the last 2 units for now : the 15-minute and single minute units. Eventually we need to handle them.
          cur_row.time = parseDateFormat1(String(cur_row.time));            // "time" is X value.
        } else if (parse_format === 2) {
          cur_row.time.splice(4, 1);                                  // TODO: remove the 15 minute unit but keep the single minutes, for this time format.
          cur_row.time = parseDateFormat2(String(cur_row.time));            // "time" is X value.
        }
        cur_row.value = +cur_row.value;                       // "value" is Y value. "+" converts the value to a number (not a string).
      });
      data.nfc = raw_data.nfc.slice();
      // console.log("1 * * * * * * * * * * NFC data = ")
      // console.log(data.nfc)
      
      // apply moving-average smoothing, if specified
      if (smoothing_amount !== undefined) {
        data.nfc = moving_window_average(data.nfc, smoothing_amount);
      }
      // console.log("2 * * * * * * * * * * NFC data = ")
      // console.log(data.nfc)

      // draw chart for these 2 teams.
      draw_chart(cur_graph, front_team, back_team, parse_format, style);
    }

    // Average our JSON data array. The steps param determines the size of the averaging window (steps is the number of data points we use on each side of our current data point).
    // function moving_window_average(array, steps) {
    //   var averaged_array = [];            // to store our averaged data

    //   array.map(function (cur_row, index) {
    //     // console.log("------------------ i : "+ index);
    //     // console.log("------------------ cur_row + array[index] : ")
    //     // console.log(cur_row);
    //     // console.log("------------------------------------")

    //     // get window of values from this original array
    //     var cur_window = array.slice(index - steps, index + steps + 1);
        
    //     // filter to use only the "value" property in the window (this, not using "time")
    //     var cur_window_value = cur_window.map( function(element){ 
    //       return element.value;
    //     });
    //     // console.log("cur_window_value = ");
    //     // console.log(cur_window_value);

    //     // average values into one value
    //     var result_value = (d3.sum(cur_window_value) / cur_window_value.length);
    //     console.log("- index: "+index)
    //     if (isNaN(result_value)) { 
    //       console.log("--- index: "+index)
    //     result_value = cur_row.value; }      // for edge values that return bad numbers, use the original number.        

        
    //     // put new averaged value into the averaged array.
    //     // console.log("---cur_row.value = "+ cur_row.value)
    //     // console.log("---result_value = "+ result_value)
    //     var new_row = {};
    //     new_row.value = result_value;
    //     new_row.time = cur_row.time;
    //     averaged_array.push(new_row)

    //     // console.log("------------------ cur_row + array[index] : ")
    //     // console.log(cur_row);
    //     // console.log(averaged_array[index]);
    //     // console.log("------------------------------------")
    //   });

    //   // console.log("------------------ array = ");
    //   // console.log(array)
    //   // console.log("------------------ averaged_array = ");
    //   // console.log(averaged_array)

    //   return averaged_array;
    // }

    // DEV : 2 new options for smoothing the edges...
    function moving_window_average(array, steps) {
      var averaged_array = [];            // to store our averaged data

      array.map(function (cur_row, index) {
        // console.log("------------------ i : "+ index);
        // console.log("------------------ cur_row + array[index] : ")
        // console.log(cur_row);
        // console.log("------------------------------------")

        // get window of values from this original array
        // console.log("******** index["+index+"]-steps = "+ array[index-steps] );
        // console.log("******** index["+index+"]+steps+1 = "+ array[index+steps+1] );
        
        if ( array[index-steps] === undefined ) {
          // console.log("-------- UNDEFINED START index: "+index);
          // result_value = cur_row.value;      // for edge values that return bad numbers, use the original number.

          // incomplete window : select from start of the array.
          var cur_window = array.slice(0, index + steps + 1);        // OPTION #1
          // var cur_window = array.slice(0, (steps * 2) + 1 );            // OPTION #2
          
        } else if ( array[index+steps+1] === undefined ) {
          // console.log("-------- UNDEFINED END index: "+index);

          // incomplete window : select until end of the array.
          var cur_window = array.slice(index - steps);                // OPTION #1
          // var cur_window = array.slice( -((steps * 2) + 1) );            // OPTION #2

        } else {
          // console.log("--- DEFINED index: "+index);
          
          // take the specified window from the array.
          var cur_window = array.slice(index - steps, index + steps + 1);
          
        }

        // filter to use only the "value" property in the window (this, not using "time")
        var cur_window_value = cur_window.map( function(element){ 
          return element.value;
        });
        // console.log("cur_window_value = ");
        // console.log(cur_window_value);

        // average values into one value
        var result_value = (d3.sum(cur_window_value) / cur_window_value.length);




        // _dev_jc_jan3
        // if (isNaN(cur_row.value)) {
        //   console.log("- - - - - - - - - - - - - - - - cur value is NAN | result_value = "+ result_value)
        // }





        // put new averaged value into the averaged array.
        // console.log("---cur_row.value = "+ cur_row.value)
        // console.log("---result_value = "+ result_value)
        var new_row = {};
        new_row.value = result_value;
        new_row.time = cur_row.time;
        averaged_array.push(new_row)

        // console.log("------------------ cur_row + array[index] : ")
        // console.log(cur_row);
        // console.log(averaged_array[index]);
        // console.log("------------------------------------")
      });

      // console.log("------------------ array = ");
      // console.log(array)
      // console.log("------------------ averaged_array = ");
      // console.log(averaged_array)

      return averaged_array;
    }

    // draw the graphs/charts
    function draw_chart(cur_graph, front_team, back_team, parse_format, style) {
      // console.log("t- draw_chart - cur_graph = "+cur_graph +" | front_team = "+ front_team +" | back_team = "+ back_team);

        
      x.domain([
        Math.min(d3.min(data.afc, function(d) { return d.time; }), d3.min(data.nfc, function(d) { return d.time; })),
        Math.max(d3.max(data.afc, function(d) { return d.time; }), d3.max(data.nfc, function(d) { return d.time; }))
      ]);
      y.domain([
        Math.min(d3.min(data.afc, function(d) { return d.value; }), d3.min(data.nfc, function(d) { return d.value; })),
        Math.max(d3.max(data.afc, function(d) { return d.value; }), d3.max(data.nfc, function(d) { return d.value; }))
      ]);
      
      
      // // Unused: pattern using line path.
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'diagonalHatch_value1')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     // .attr('width', 4)
      //     // .attr('height', 4)
      //     .attr('width', 10)
      //     .attr('height', 10)
      //   .append('path')
      //     // .attr('d', 'M-1,3 l2,2 M0,0 l4,4 M3,-1 l2,2')
      //     .attr('d', 'M-1,9 l2,2 M0,0 l10,10 M9,-1 l2,2')
      //     .attr('stroke', '#FF6319')
      //     .attr('stroke-width', 2);
      // // // Unused: pattern using line path.
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'diagonalHatch_value2')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     .attr('width', 4)
      //     .attr('height', 4)
      //     // .attr('width', 10)
      //     // .attr('height', 10)
      //   .append('path')
      //     .attr('d', 'M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2')
      //     // .attr('d', 'M-1,9 l2,2 M0,0 l10,10 M9,-1 l2,2')
      //     .attr('stroke', '#C60C30')
      //     .attr('stroke-width', 1);
      // // Unused: pattern using line path.
      cur_graph
        .append('defs')
        .append('pattern')
          .attr('id', 'crosshatch')
          .attr('patternUnits', 'userSpaceOnUse')
          // .attr('width', 4)
          // .attr('height', 4)
          .attr('width', 6)
          .attr('height', 6)
        .append('path')
          // .attr('d', 'M-1,3 l2,2 M0,0 l4,4 M3,-1 l2,2')
          .attr('d', 'M-1,5 l2,2 M0,0 l6,6 M5,-1 l2,2')
          .attr('stroke', cur_colors[front_team])
          .attr('stroke-width', 1.5);
      // - - - - - - - - - - - - - - - - - - - - - - - - 
      // // DEV : Hashing 1
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'diagonalHatch_value1')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     .attr('width', 10)
      //     .attr('height', 10)
      //   .append('path')
      //     .attr('d', 'M-1,9 l2,2 M0,0 l10,10 M9,-1 l2,2')
      //     .attr('stroke', '#FF6319')
      //     .attr('stroke-width', 2);
      // // Unused: pattern using line path.
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'diagonalHatch_value2')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     .attr('width', 4)
      //     .attr('height', 4)
      //   .append('path')
      //     .attr('d', 'M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2')
      //     .attr('stroke', '#0D254C')
      //     .attr('stroke-width', 1);
      // - - - - - - - - - - - - - - - - - - - - - - - - 
      // // Unused: pattern using GIF image.
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'pattern-image')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     .attr('width', 20)
      //     .attr('height', 20)
      //   .append('svg:image')
      //     .attr('width', 20)
      //     .attr('height', 20)
      //     .attr('xlink:href', 'img/pattern-1.gif');


      

      // ----------------------------- DATASET IN BACK -----------------------------
      
      // TODO: make drawing the line an optional parameter.
      // // Unused: draw the line on the data points.
      // var line = d3.svg.line()
      //   .x(function(d) { return x(d.time); })
      //   .y(function(d) { return y(d.value); });
      // cur_graph.append("path")
      //   .datum(data[back_team])
      //   .attr("class", "line " + back_team +" "+ cur_teams[back_team])
      //   .attr("d", line);

      // draw the colored fill area under the line.
      var area = d3.svg.area()
        .x(function(d) { return x(d.time); })
        .y0(height)
        .y1(function(d,i) {
          return y(d.value);
      })
      .interpolate("basis");
      cur_graph.append("path")
        .datum(data[back_team])
        .attr("class", "area " + back_team +" "+ cur_teams[back_team])
        .attr("d", area);
      
      // ----------------------------- DATASET IN FRONT -----------------------------
      
      // TODO: make drawing the line an optional parameter.
      // Unused: draw the line on the data points.
      var line = d3.svg.line()
        .x(function(d) { return x(d.time); })
        .y(function(d) { return y(d.value); })
        .interpolate("basis");
      cur_graph.append("path")
        .datum(data[front_team])
        .attr("class", "line " + front_team +" "+ cur_teams[front_team])
        .attr("d", line);
        
      // draw the colored fill area under the line.
      var area = d3.svg.area()
        .x(function(d) { return x(d.time); })
        .y0(height)
        .y1(function(d,i) {
          return y(d.value);
      })
      .interpolate("basis");
      var cur_path = cur_graph.append("path")
        .datum(data[front_team])
        .attr("class", "area " + front_team +" "+ cur_teams[front_team])
        .attr("d", area);

      // Firefox exception: pattern must be applied inline here to display correctly, not in a stylesheet.
      if (style !== undefined ) { 
        cur_path.attr("style", "fill: url('#crosshatch');opacity: 1;");
      }

      // ----------------------------- LINE FROM BACK DATASET IN FRONT OF EVERYTHING -----------------------------
    
      // TODO: make drawing the line an optional parameter.
      // // Unused: draw the line on the data points.
      // var line = d3.svg.line()
      //   .x(function(d) { return x(d.time); })
      //   .y(function(d) { return y(d.value); });
      // cur_graph.append("path")
      //   .datum(data[back_team])
      //   .attr("class", "line " + back_team +" "+ cur_teams[back_team])
      //   .attr("d", line);

      // ---------------------------------------------------------------------------

      // Draw the X-axis of the graph.
      cur_graph.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

      // Draw the Y-axis of the graph.
      cur_graph.append("g")
          .attr("class", "y axis")
          .call(yAxis)
        .append("text")
          .attr("transform", "rotate(-90)")
          .attr("y", 6)
          .attr("dy", ".71em")
          .style("text-anchor", "end")
          .attr("class", "axis-text")
          .text("value");

    }
    
  </script>
  
  </body>
</html>