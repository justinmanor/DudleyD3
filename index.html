<!DOCTYPE html>
<html>
  <meta charset="utf-8">
  <head>
    <title>DudleyD3 - Sosolimited</title>
    <link rel="stylesheet" type="text/css" href="css/style.css">
  </head>
  <body>
    <div class="wrapper">

      <div id="game_title"><h1>Dudley D3 Dashboard</h1></div>

      <div id="graph_container_2" class=" graph_container full_row">
        <h2>Overall Requests/Day</h2>
        <div id="graph_1"></div>
      </div>
      
    </div>
    
  <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <script src="js/common.js"></script>
  <script type="text/javascript" charset="utf-8">
    
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - General - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // Set default teams and colors. Is overwritten by results of our JSON calls.
    var cur_teams = { "afc" : "none", "nfc" : "none" };
    var cur_colors = { "afc" : "black", "nfc" : "black" };

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Vars : Time series charts - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // to store the current chart's data
    var data;

    // Vars for all charts size.
    margin = {top: 30, right: 30, bottom: 30, left: 40};
    width = 950 - margin.left - margin.right;
    height = 400 - margin.top - margin.bottom;
    // Our Date parsing formats.
    // TODO: right now the way we handle different data streams is by ignorning whole unit measures (ie. 15 minutes, single minutes) instead of treating individual null values. Need to add handling for that.
    // We have different parsing formats depending on the type of data: daily, hourly, by minute, etc.
    var parseDateFormat1 = d3.time.format("%Y,%m,%d,%H").parse;             // For data per hour. "%-" means it ignores padding, removing the need for zero-padding perhaps?
    var parseDateFormat2 = d3.time.format("%Y,%m,%d,%H,%M").parse;          // For data per minute.

    // Setup X and Y scales.
    // x = d3.time.scale()
    //     .range([0, width]);
    // y = d3.scale.linear()
    //     .range([height, 0]);
    // // Setup X and Y axis, using the scales.
    // xAxis = d3.svg.axis()
    //     .scale(x)
    //     .orient("bottom");
    // yAxis = d3.svg.axis()
    //     .scale(y)
    //     .orient("left");
    
    // Setup a date objects for setting START and END params for the query string.
    var cur_date = new Date();                                                          // get current date.
    // var cur_date=new Date("2009 06 05,12:09:39");                 // DEV : for testing
    // console.log("DATE today = " + cur_date)
    var timezone_offset = cur_date.getTimezoneOffset();                       // time difference to UTC
    // console.log("GMT offset = " + timezone_offset);
    var diffFromEST = timezone_offset/60 -5;                                  // time diff to EST
    // console.log("EST offset = " + diffFromEST);
    var hours_of_data = 6;                                                    // is hours of data we want to retrieve in the past.
    
    // ------- Setup End Date (ie. current date in time)
    var endDate = new Date(cur_date.getTime());             // clone current local date to create current EST date.
    endDate.setHours(endDate.getHours() + diffFromEST);     // set date to EST time.
    var endMonth = String("0" + Number(endDate.getMonth()+1)).slice(-2);                // add 1 to month since it's normally from [0-11]. Also add a zero fopr zero-padding single-digit values.
    var endDay = String("0" + endDate.getDate()).slice(-2);
    var endHours = String("0" + endDate.getHours()).slice(-2);
    var endMinutes = String("0" + endDate.getMinutes()).slice(-2);    
    var formattedEndDate = String( endDate.getFullYear() +"-"+ endMonth +"-"+ endDay +"T"+ endHours +":"+ endMinutes );     // format the entire time string in the format "2013-12-03T10:00".
    // console.log("FORMATTED END DATE = " + formattedEndDate )

    // ------- Setup Start Date (ie. a date in the past)
    var startDate = new Date(endDate.getTime());                   // clone current EST date to create past EST date.
    startDate.setHours(startDate.getHours() - hours_of_data);      // set date to "hours_of_data" hours ago (again, in EST time).
    // console.log("DATE - 6 hours = " + startDate)
    var startMonth = String("0" + Number(startDate.getMonth()+1)).slice(-2);                // add 1 to month since it's normally from [0-11]. Also add a zero fopr zero-padding single-digit values.
    var startDay = String("0" + startDate.getDate()).slice(-2);
    var startHours = String("0" + startDate.getHours()).slice(-2);
    var startMinutes = String("0" + startDate.getMinutes()).slice(-2);    
    var formattedStartDate = String( startDate.getFullYear() +"-"+ startMonth +"-"+ startDay +"T"+ startHours +":"+ startMinutes );     // format the entire time string in the format "2013-12-03T10:00".
    // console.log("FORMATTED START DATE = " + formattedStartDate )
    // To store all chart SVG objects
    var charts = [];    
    // For each chart, this array contains : [0] = the data url, [1] = the desired front dataset (the AFC team or NFC team), [2] = the desired back dataset (AFC or NFC), [3] = the parse format, (optional)[4] = the smoothing amount.
    // Some data urls are the live API, some are backed-up data files.
    var charts_data = [ 
                        // ["http://wgwapi.com/game/confidence?time=min&start=" + formattedStartDate + "&end=" +formattedEndDate, "nfc", "afc", 2, 20, true]
                        // ["https://mayors24.cityofboston.gov/open311/v2/requests.json?page=1&page_size=10"]
                        // ["http://sosolimited.com/superbowl/WGW-D3-Charts/data/data-nov7chiefsbroncos-tweets-timemin-num1440.json"]
                        ["data/dudley-page=1&page_size=10.json"]
                      ];
    
    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Init : Time series charts - - -- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // this call starts everything.
    setup_charts();

    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - Functions - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

    // setup chart objects and data.
    function setup_charts() {
      
      for (var i = 0; i < charts_data.length; i++) {

          var cur_chart = d3.select("#graph_" + (i+1) ).append("svg")
              .attr("width", width + margin.left + margin.right)
              .attr("height", height + margin.top + margin.bottom)
              .attr("top", 100)
            .append("g")                                // "g" is a SVG group element for applying properties to many objects at once.
              .attr("transform", "translate(" + margin.left + "," + margin.top + ")");  
          // store the chart.
          charts[i] = cur_chart;

        // }

        // Call the JSON data. For the data we currently have, value1 = Broncos (orange), and value2 = Chiefs (red).
        // Using a function/closure to localize "i" (and giving it another name, "this_i") so that "i" doesn't always end-up being the last index of the loop.
        (function(this_i){      //"localizing" i by using it in the inner function
          
          d3.json(charts_data[this_i][0], function(error, json_data) {
            
            console.log("- - - - - - - - - - - - - - - - - - #"+ this_i +" DATA : ")
            console.log(json_data);

            // - - - - MAKE CHART HERE

            var parseDateFormat = d3.time.format("%Y-%m-%dT%H:%M:%S").parse;          // For data per minute.
            
            x = d3.time.scale()
                .range([0, width]);
            y = d3.scale.linear()
                .range([height, 0]);
            
            xAxis = d3.svg.axis()
                .scale(x)
                .orient("bottom");
            yAxis = d3.svg.axis()
                .scale(y)
                .orient("left");

            var line = d3.svg.line()
              .x(function(d) { return x(d.requested_datetime); })
              .y(function(d) { return y(d.service_request_id); });
              // .interpolate("basis");

            json_data.map(function (cur_row, index) {
              console.log("MAP -- index: "+ index);
              console.log("service_request_id = "+ cur_row.service_request_id);
              cur_row.requested_datetime = cur_row.requested_datetime.slice(0, -6);     // remove timezone at end.
              console.log("requested_datetime = "+ cur_row.requested_datetime);
              cur_row.requested_datetime = parseDateFormat(String(cur_row.requested_datetime));
              console.log("requested_datetime = "+ cur_row.requested_datetime);

              cur_row.service_request_id = +cur_row.service_request_id;
            });

            x.domain(d3.extent(json_data, function(d){ return d.requested_datetime; }));
            y.domain(d3.extent(json_data, function(d){ return d.service_request_id; }));

            // Draw the X-axis of the graph.
            charts[this_i].append("g")
                .attr("class", "x axis")
                .attr("transform", "translate(0," + height + ")")
                .call(xAxis);

            // Draw the Y-axis of the graph.
            charts[this_i].append("g")
                .attr("class", "y axis")
                .call(yAxis)
              .append("text")
                .attr("transform", "rotate(-90)")
                .attr("y", 6)
                .attr("dy", ".71em")
                .style("text-anchor", "end")
                .attr("class", "axis-text")
                .text("BLAH");
          
            charts[this_i].append("path")
                .datum(json_data)
                .attr("class", "line")
                .attr("d", line);

          });

        }(i));    //pass in our "i" from the loop
      }

    }
    
    // Preprocess the raw data.
    function format_raw_data(raw_data, cur_graph, front_team, back_team, parse_format, smoothing_amount, style) {
      data = {};      // clear data array
      
      // TODO: shorten code by formatting AFC and NFC in a loop of some sort.

      // AFC ----------------------------------------------------
      // rip out data from the AFC object to populate our new data array.
      raw_data.afc.map(function (cur_row, index) {
        // console.log(cur_row);
        // console.log(cur_row.time[4]);
        if (parse_format === 1) {
          cur_row.time.splice(4);                                     // TODO: removes the last 2 units for now : the 15-minute and single minute units. Eventually we need to handle them.
          cur_row.time = parseDateFormat1(String(cur_row.time));            // "time" is X value.
        } else if (parse_format === 2) {
          cur_row.time.splice(4, 1);                                  // TODO: remove the 15 minute unit but keep the single minutes, for this time format.
          cur_row.time = parseDateFormat2(String(cur_row.time));            // "time" is X value.
        }
        cur_row.value = +cur_row.value;                       // "value" is Y value. "+" converts the value to a number (not a string).
      });
      data.afc = raw_data.afc.slice();
      // console.log("1 * * * * * * * * * * AFC data = ")
      // console.log(data.afc)
      
      // apply moving-average smoothing, if specified
      if (smoothing_amount !== undefined) {
        data.afc = moving_window_average(data.afc, smoothing_amount);
      }
      // console.log("2 * * * * * * * * * * AFC data = ")
      // console.log(data.afc)

      // NFC ----------------------------------------------------
      // rip out data from the NFC object to populate our new data array.
      raw_data.nfc.map(function (cur_row, index) {
        // console.log(cur_row);
        // console.log(cur_row.time[4]);
        if (parse_format === 1) {
          cur_row.time.splice(4);                                     // TODO: removes the last 2 units for now : the 15-minute and single minute units. Eventually we need to handle them.
          cur_row.time = parseDateFormat1(String(cur_row.time));            // "time" is X value.
        } else if (parse_format === 2) {
          cur_row.time.splice(4, 1);                                  // TODO: remove the 15 minute unit but keep the single minutes, for this time format.
          cur_row.time = parseDateFormat2(String(cur_row.time));            // "time" is X value.
        }
        cur_row.value = +cur_row.value;                       // "value" is Y value. "+" converts the value to a number (not a string).
      });
      data.nfc = raw_data.nfc.slice();
      // console.log("1 * * * * * * * * * * NFC data = ")
      // console.log(data.nfc)
      
      // apply moving-average smoothing, if specified
      if (smoothing_amount !== undefined) {
        data.nfc = moving_window_average(data.nfc, smoothing_amount);
      }
      // console.log("2 * * * * * * * * * * NFC data = ")
      // console.log(data.nfc)

      // draw chart for these 2 teams.
      draw_chart(cur_graph, front_team, back_team, parse_format, style);
    }

    // Average our JSON data array. The steps param determines the size of the averaging window (steps is the number of data points we use on each side of our current data point).
    // function moving_window_average(array, steps) {
    //   var averaged_array = [];            // to store our averaged data

    //   array.map(function (cur_row, index) {
    //     // console.log("------------------ i : "+ index);
    //     // console.log("------------------ cur_row + array[index] : ")
    //     // console.log(cur_row);
    //     // console.log("------------------------------------")

    //     // get window of values from this original array
    //     var cur_window = array.slice(index - steps, index + steps + 1);
        
    //     // filter to use only the "value" property in the window (this, not using "time")
    //     var cur_window_value = cur_window.map( function(element){ 
    //       return element.value;
    //     });
    //     // console.log("cur_window_value = ");
    //     // console.log(cur_window_value);

    //     // average values into one value
    //     var result_value = (d3.sum(cur_window_value) / cur_window_value.length);
    //     console.log("- index: "+index)
    //     if (isNaN(result_value)) { 
    //       console.log("--- index: "+index)
    //     result_value = cur_row.value; }      // for edge values that return bad numbers, use the original number.        

        
    //     // put new averaged value into the averaged array.
    //     // console.log("---cur_row.value = "+ cur_row.value)
    //     // console.log("---result_value = "+ result_value)
    //     var new_row = {};
    //     new_row.value = result_value;
    //     new_row.time = cur_row.time;
    //     averaged_array.push(new_row)

    //     // console.log("------------------ cur_row + array[index] : ")
    //     // console.log(cur_row);
    //     // console.log(averaged_array[index]);
    //     // console.log("------------------------------------")
    //   });

    //   // console.log("------------------ array = ");
    //   // console.log(array)
    //   // console.log("------------------ averaged_array = ");
    //   // console.log(averaged_array)

    //   return averaged_array;
    // }

    // DEV : 2 new options for smoothing the edges...
    function moving_window_average(array, steps) {
      var averaged_array = [];            // to store our averaged data

      array.map(function (cur_row, index) {
        // console.log("------------------ i : "+ index);
        // console.log("------------------ cur_row + array[index] : ")
        // console.log(cur_row);
        // console.log("------------------------------------")

        // get window of values from this original array
        // console.log("******** index["+index+"]-steps = "+ array[index-steps] );
        // console.log("******** index["+index+"]+steps+1 = "+ array[index+steps+1] );
        
        if ( array[index-steps] === undefined ) {
          // console.log("-------- UNDEFINED START index: "+index);
          // result_value = cur_row.value;      // for edge values that return bad numbers, use the original number.

          // incomplete window : select from start of the array.
          var cur_window = array.slice(0, index + steps + 1);        // OPTION #1
          // var cur_window = array.slice(0, (steps * 2) + 1 );            // OPTION #2
          
        } else if ( array[index+steps+1] === undefined ) {
          // console.log("-------- UNDEFINED END index: "+index);

          // incomplete window : select until end of the array.
          var cur_window = array.slice(index - steps);                // OPTION #1
          // var cur_window = array.slice( -((steps * 2) + 1) );            // OPTION #2

        } else {
          // console.log("--- DEFINED index: "+index);
          
          // take the specified window from the array.
          var cur_window = array.slice(index - steps, index + steps + 1);
          
        }

        // filter to use only the "value" property in the window (this, not using "time")
        var cur_window_value = cur_window.map( function(element){ 
          return element.value;
        });
        // console.log("cur_window_value = ");
        // console.log(cur_window_value);

        // average values into one value
        var result_value = (d3.sum(cur_window_value) / cur_window_value.length);




        // _dev_jc_jan3
        // if (isNaN(cur_row.value)) {
        //   console.log("- - - - - - - - - - - - - - - - cur value is NAN | result_value = "+ result_value)
        // }





        // put new averaged value into the averaged array.
        // console.log("---cur_row.value = "+ cur_row.value)
        // console.log("---result_value = "+ result_value)
        var new_row = {};
        new_row.value = result_value;
        new_row.time = cur_row.time;
        averaged_array.push(new_row)

        // console.log("------------------ cur_row + array[index] : ")
        // console.log(cur_row);
        // console.log(averaged_array[index]);
        // console.log("------------------------------------")
      });

      // console.log("------------------ array = ");
      // console.log(array)
      // console.log("------------------ averaged_array = ");
      // console.log(averaged_array)

      return averaged_array;
    }

    // draw the graphs/charts
    function draw_chart(cur_graph, front_team, back_team, parse_format, style) {
      // console.log("t- draw_chart - cur_graph = "+cur_graph +" | front_team = "+ front_team +" | back_team = "+ back_team);

        
      x.domain([
        Math.min(d3.min(data.afc, function(d) { return d.time; }), d3.min(data.nfc, function(d) { return d.time; })),
        Math.max(d3.max(data.afc, function(d) { return d.time; }), d3.max(data.nfc, function(d) { return d.time; }))
      ]);
      y.domain([
        Math.min(d3.min(data.afc, function(d) { return d.value; }), d3.min(data.nfc, function(d) { return d.value; })),
        Math.max(d3.max(data.afc, function(d) { return d.value; }), d3.max(data.nfc, function(d) { return d.value; }))
      ]);
      
      
      // // Unused: pattern using line path.
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'diagonalHatch_value1')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     // .attr('width', 4)
      //     // .attr('height', 4)
      //     .attr('width', 10)
      //     .attr('height', 10)
      //   .append('path')
      //     // .attr('d', 'M-1,3 l2,2 M0,0 l4,4 M3,-1 l2,2')
      //     .attr('d', 'M-1,9 l2,2 M0,0 l10,10 M9,-1 l2,2')
      //     .attr('stroke', '#FF6319')
      //     .attr('stroke-width', 2);
      // // // Unused: pattern using line path.
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'diagonalHatch_value2')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     .attr('width', 4)
      //     .attr('height', 4)
      //     // .attr('width', 10)
      //     // .attr('height', 10)
      //   .append('path')
      //     .attr('d', 'M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2')
      //     // .attr('d', 'M-1,9 l2,2 M0,0 l10,10 M9,-1 l2,2')
      //     .attr('stroke', '#C60C30')
      //     .attr('stroke-width', 1);
      // // Unused: pattern using line path.
      cur_graph
        .append('defs')
        .append('pattern')
          .attr('id', 'crosshatch')
          .attr('patternUnits', 'userSpaceOnUse')
          // .attr('width', 4)
          // .attr('height', 4)
          .attr('width', 6)
          .attr('height', 6)
        .append('path')
          // .attr('d', 'M-1,3 l2,2 M0,0 l4,4 M3,-1 l2,2')
          .attr('d', 'M-1,5 l2,2 M0,0 l6,6 M5,-1 l2,2')
          .attr('stroke', cur_colors[front_team])
          .attr('stroke-width', 1.5);
      // - - - - - - - - - - - - - - - - - - - - - - - - 
      // // DEV : Hashing 1
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'diagonalHatch_value1')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     .attr('width', 10)
      //     .attr('height', 10)
      //   .append('path')
      //     .attr('d', 'M-1,9 l2,2 M0,0 l10,10 M9,-1 l2,2')
      //     .attr('stroke', '#FF6319')
      //     .attr('stroke-width', 2);
      // // Unused: pattern using line path.
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'diagonalHatch_value2')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     .attr('width', 4)
      //     .attr('height', 4)
      //   .append('path')
      //     .attr('d', 'M-1,1 l2,-2 M0,4 l4,-4 M3,5 l2,-2')
      //     .attr('stroke', '#0D254C')
      //     .attr('stroke-width', 1);
      // - - - - - - - - - - - - - - - - - - - - - - - - 
      // // Unused: pattern using GIF image.
      // cur_graph
      //   .append('defs')
      //   .append('pattern')
      //     .attr('id', 'pattern-image')
      //     .attr('patternUnits', 'userSpaceOnUse')
      //     .attr('width', 20)
      //     .attr('height', 20)
      //   .append('svg:image')
      //     .attr('width', 20)
      //     .attr('height', 20)
      //     .attr('xlink:href', 'img/pattern-1.gif');


      

      // ----------------------------- DATASET IN BACK -----------------------------
      
      // TODO: make drawing the line an optional parameter.
      // // Unused: draw the line on the data points.
      // var line = d3.svg.line()
      //   .x(function(d) { return x(d.time); })
      //   .y(function(d) { return y(d.value); });
      // cur_graph.append("path")
      //   .datum(data[back_team])
      //   .attr("class", "line " + back_team +" "+ cur_teams[back_team])
      //   .attr("d", line);

      // draw the colored fill area under the line.
      var area = d3.svg.area()
        .x(function(d) { return x(d.time); })
        .y0(height)
        .y1(function(d,i) {
          return y(d.value);
      })
      .interpolate("basis");
      cur_graph.append("path")
        .datum(data[back_team])
        .attr("class", "area " + back_team +" "+ cur_teams[back_team])
        .attr("d", area);
      
      // ----------------------------- DATASET IN FRONT -----------------------------
      
      // TODO: make drawing the line an optional parameter.
      // Unused: draw the line on the data points.
      var line = d3.svg.line()
        .x(function(d) { return x(d.time); })
        .y(function(d) { return y(d.value); })
        .interpolate("basis");
      cur_graph.append("path")
        .datum(data[front_team])
        .attr("class", "line " + front_team +" "+ cur_teams[front_team])
        .attr("d", line);
        
      // draw the colored fill area under the line.
      var area = d3.svg.area()
        .x(function(d) { return x(d.time); })
        .y0(height)
        .y1(function(d,i) {
          return y(d.value);
      })
      .interpolate("basis");
      var cur_path = cur_graph.append("path")
        .datum(data[front_team])
        .attr("class", "area " + front_team +" "+ cur_teams[front_team])
        .attr("d", area);

      // Firefox exception: pattern must be applied inline here to display correctly, not in a stylesheet.
      if (style !== undefined ) { 
        cur_path.attr("style", "fill: url('#crosshatch');opacity: 1;");
      }

      // ----------------------------- LINE FROM BACK DATASET IN FRONT OF EVERYTHING -----------------------------
    
      // TODO: make drawing the line an optional parameter.
      // // Unused: draw the line on the data points.
      // var line = d3.svg.line()
      //   .x(function(d) { return x(d.time); })
      //   .y(function(d) { return y(d.value); });
      // cur_graph.append("path")
      //   .datum(data[back_team])
      //   .attr("class", "line " + back_team +" "+ cur_teams[back_team])
      //   .attr("d", line);

      // ---------------------------------------------------------------------------

      // Draw the X-axis of the graph.
      cur_graph.append("g")
          .attr("class", "x axis")
          .attr("transform", "translate(0," + height + ")")
          .call(xAxis);

      // Draw the Y-axis of the graph.
      cur_graph.append("g")
          .attr("class", "y axis")
          .call(yAxis)
        .append("text")
          .attr("transform", "rotate(-90)")
          .attr("y", 6)
          .attr("dy", ".71em")
          .style("text-anchor", "end")
          .attr("class", "axis-text")
          .text("value");

    }
    
  </script>
  
  </body>
</html>